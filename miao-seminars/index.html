<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html lang="en"><head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">

<link rel="icon" href="http://www.jakobnordstrom.se/MIAOlogo.ico">
<link rel="stylesheet" type="text/css" href="../index-filer/kod-html.css">


<title>
Jakob Nordström: MIAO seminars</title>
</head>
<body>

<table class="innehall_ram" width="634" cellspacing="0" cellpadding="0" border="0">
<tbody><tr>

<td valign="top">
<div class="innehall">
<a name="topofpage"></a>


<!-- Hard-coded "menu" at top of page -->

<table width="100%">
<tbody><tr><td valign="top" align="left">
<span class="sokvag_nedflyttad">
  <a href="http://www.jakobnordstrom.se">Jakob Nordström</a>
/ MIAO seminars</span>
</td>
</tr>
</tbody></table>


<h1>
  MIAO Seminars
</h1>

<p> 

  The
  <em>MIAO seminars</em>
  are what we call the series of seminars arranged  by the
  <a href="http://www.jakobnordstrom.se/miao-group/">Mathematical
    Insights into Algorithms for Optimization (MIAO)
    research group</a>
  at the University of Copenhagen and Lund University.
</p>

<p>
  Our seminars often (but far from always) consist of two parts: first
  a regular talk, and after this a ca-1-hour informal, technical
  presentation with discussions. The intention is that all listeners
  will first get an overview of some exciting research results, and
  then people who find the topic particularly interesting will get an
  opportunity to study the same material more in-depth.
</p>

<p>
  To elaborate a bit, for seminars conducted in this format the first
  part is just a standard, listener-friendly seminar of 50-55 minutes
  (including time for questions). The audience is assumed to have a
  general knowledge of computer science and/or mathematics, but is not
  expected to have any detailed insights into the specific area covered
  by the talk.  This first part is intended to be self-contained, since most
  attendees tend to leave after the first part.
</p>

<p>
  After a ca-10-minute break it is time for the second part, when
  those who are interested reconvene for a more in-depth technical
  presentation. During this second part the goal is to "open up the
  hood", so that for a theory talk we look at the formal definitions
  and prove at least some of the key ingredients in the results
  including all (or at least some of) the gory technical details
  glossed over in a polished seminar presentation. For a more applied
  talk, we might go into questions of implementation or discuss
  detailed experimental results. Questions and discussions are
  strongly encouraged.  However, for those who feel that the first
  50-55-minute regular seminar was enough for today, it is perfectly
  fine to just discretely drop out during the break. No excuses
  needed; no questions asked.
</p>

<p>
  These seminars typically have a low-key, informal, atmosphere, but
  they are open to the public and are announced beforehand on
  our seminar mailing lists (with two different lists for more
  theoretically oriented or more applied seminars, respectively).
  In case you want to receive the announcements, please just let us
  know by sending an e-mail message to jn@di.ku.dk
  specifying which seminar mailing list you wish to be added to
  (theoretical, applied, or both).
  We also add all public seminars to the
  <a href="https://calendar.google.com/calendar/u/0?cid=OTgzYmk1dTZwY21wbDVmbGxtOGtwZGg2djBAZ3JvdXAuY2FsZW5kYXIuZ29vZ2xlLmNvbQ">MIAO seminar calendar</a>.
</p>
  
<p>
  In response to multiple requests, since the spring
  of 2021 we have started recording most seminars. The recordings are posted on the
  MIAO Research YouTube channel
  <a href="https://youtube.com/@MIAOresearch">youtube.com/@MIAOresearch</a>.
</p>

<p>
  All seminar times below are in the Central European Time Zone
  (with daylight saving time observed from the last Sunday in March to
  the last Sunday in October).
</p>

<h2>Upcoming seminars</h2>
  
<!--
<p>
  <em>
    The MIAO seminars have switched to
    vacation mode, but we plan to be back in  September.
    <!-
     Please note that the dates below are still a bit tentative, though.
     All times below are in the Central European time zone (with or without daylight savings as appropriate).
  </em>
</p>
-->

<ul>
  
  <li>
    <p>
      Monday Nov 21 at 14:00 in Copenhagen and on Zoom
      <br>
      <strong>
	Bounded depth proof for Tseitin formulas on the grid; revisited
      </strong>
      <br>
      (Kilian Risse, KTH Royal Institute of Technology)
    </p>      
    
    <p>
      In this seminar we are going to study the Frege proof system: a Frege
      refutation of a CNF formula <em>F</em> is a sequence of Boolean formulas, where
      each formula is either a clause from <em>F</em> or follows from two previously
      derived formulas according to some derivation rule. The final formula
      in the sequence should be the constant false formula so that if the
      derivation rules are sound, then we can conclude that <em>F</em> has no
      satisfying assignment. The length of a refutation is the number of
      formulas in the sequence, the depth is the maximum (logical) depth of
      any formula occurring and, similarly, the line-size is the maximum
      size of any formula in the sequence.
    </p>      
    
    <p>	
      We consider Frege refutations restricted to depth <em>d</em> and line-size
      <em>M</em> of the Tseitin formula defined over the <em>n</em> &#215; <em>n</em> grid and show
      that such refutations are of length exponential in
      <em>n / (</em>log <em>M)</em><sup><em>{O(d)}</em></sup>. This improves upon a recent result of
      [Pitassi et al. '21]. The key technical step is a
      multi-switching lemma extending the switching lemma of
      [Håstad '17] for a space of restrictions related to the
      Tseitin contradiction.
    </p>      
    
    <p>	
      The first hour includes a gentle introduction to the Frege proof system
      and covers the necessary background to prove our lower bounds. In the
      second hour we are going to start with a sketch of the single switching
      lemma and, if time permits, we then cover the proof of the
      multi-switching lemma.
    </p>      
    
    <p>	
      Based on joint work with Johan Håstad. Preprint available at
      <a href="https://arxiv.org/abs/2209.05839">arxiv.org/abs/2209.05839</a>.	
    </p>
    
  <li>
    <p>
      Friday Nov 25 at 14:00 in Copenhagen and on Zoom
      <br>
      <strong>
	SoS degree lower bound for exact clique
      </strong>
      <br>
      (Shuo Pang, University of Copenhagen)
    </p>      
    
    <p>
      Consider the claim that "the graph <em>G</em> is <em>w</em>-clique-free", where <em>w</em> is a
      fixed parameter greater than, say, 2 log <em>n</em>. We know by simple
      counting that the claim is true with high probability over
      <em>G</em> &sim;
      <em>G(n,1/2)</em>, but how about proving it for the given sample
      <em>G</em> &mdash; is it almost always hard?
    </p>      
    
    <p>	
      A closely related algorithmic problem is called
      <em>planted clique</em>. It asks to devise an efficient algorithm whose
      acceptance rates differ significantly with respect to samples from
      <em>G(n,1/2)</em> and from <em>G(n,1/2,w)</em>, where the latter distribution
      draws a graph from <em>G(n,1/2)</em> and then independently "plants" a
      random <em>w</em>-clique. The current state-of-the-art polynomial-time
      algorithm only succeeds when <em>w</em> is as large as &Omega;(sqrt(<em>n</em>)),
      and its correctness relies on degree 2 Sum-of-Squares proofs
      (SoS). This connection, among others, motivated the study of a
      cleanly formulated proof-theoretic question: Can higher degree
      SoS do better on average, i.e., prove "<em>G</em> is <em>w</em>-clique-free" for
      significantly smaller <em>w</em> and most <em>G</em> from <em>G(n,1/2)</em>?
    </p>      
    
    <p>	
      After a long line of work, it turns out <em>w</em>=sqrt(<em>n</em>) is
      essentially the optimal value that SoS proofs of a reasonable
      degree can achieve. I will review the recent strongest version
      of this result, where SoS could fully employ all the
      constraints, including the one for the objective value.
    </p>
    
  <li>
    <p>
      Monday Nov 28 at 14:00 on Zoom
      <br>
      <strong>
	Combinatorial solving with provably correct results
      </strong>
      <br>
      (Bart Bogaerts, Vrije Universiteit Brussel;
      Ciaran McCreesh, University of Glasgow;
      and 
      Jakob Nordström, University of Copenhagen and Lund University)
    </p>      
    
    <p>
      Modern combinatorial optimization has had a major impact in
      science and industry, but there is a quite poor scientific
      understanding how state-of-the-art algorithms, so-called
      combinatorial solvers, work. More importantly, even mature
      commercial solvers are known to sometimes produce wrong
      results, which can be fatal for some types of applications.
    </p>
    
    <p>	
      One way to address this problem is to enhance combinatorial
      solvers with <em>proof logging</em>, meaning that they output
      not only a result but also a proof of correctness. One can
      then feed the problem, result, and proof to a dedicated
      proof checker to verify that there are no errors. Crucially,
      such proofs should require low overhead to generate and be
      easy to check, but should supply 100% guarantees of
      correctness.
    </p>
    
    <p>
      In this tutorial, we will survey recent progress on proof
      logging techniques for Boolean satisfiability (SAT) solving,
      pseudo-Boolean optimization, and constraint programming. We
      will argue that moving from the clausal format employed in
      SAT proof logging to so-called pseudo-Boolean reasoning using
      0-1 integer linear constraints seems to hit a sweet spot
      between on the one hand making proofs simple and easy to
      verify and on the other hand providing sufficient expressive
      power to support the sophisticated reasoning in more general
      combinatorial optimization paradigms.
    </p>
    
    
  <li>
    <p>
      Thursday Dec 1 at 14:00  in Copenhagen and on Zoom
      <br>
      <strong>
	Lower bounds for algebraic formulas
      </strong>
      <br>
      (Srikanth Srinivasan, Aarhus University)
    </p>      
    
    <p>
      Say we have a multivariate polynomial <em>P(x_1,..., x_n)</em>. An
      algebraic formula for <em>P</em> is just an algebraic expression for <em>P</em> with
      nested additions and multiplications. A small formula for <em>P</em> implies an
      efficient algorithm for evaluating <em>P</em>, and so a lower bound on the size
      of any such expression implies that <em>P</em> is possibly hard to evaluate.
    </p>
    
    <p>
      How would you show that your favourite polynomial <em>P</em> has no small
      formula? In this talk, we will see a technique (building on works of
      Nisan, Wigderson and Raz) for doing this that combines some linear
      algebra with random restrictions, which are a classical tool in
      circuit complexity. This helps us prove lower bounds for special kinds
      of algebraic formulas, called set-multilinear formulas.
    </p>
    
    <p>
      Based on joint work with Nutan Limaye (ITU) and Sébastien Tavenas
      (USMB, Univ Grenoble). The paper can be found at
      <a href="https://eccc.weizmann.ac.il/report/2021/094/">eccc.weizmann.ac.il/report/2021/094/</a>.
    </p>
    
  <li>
    <p>
      Tuesday Dec 6 at 14:00 in Copenhagen and on Zoom
      <br>
      <strong>
	Title TBD
      </strong>
      <br>
      (Matti Järvisalo, University of Helsinki)
    </p>      
    
    
  <li>
    <p>
      Wednesday Dec 7 at 14:00 in Lund and on Zoom
      <br>
      <strong>
	Title TBD
      </strong>
      <br>
      (Jeremias Berg, University of Helsinki)
    </p>      
    
  <li>
    <p>
      Monday Jan 9 at 14:00 on Zoom
      <br>
      <strong>
	Cut generation procedures via decision diagrams
      </strong>
      <br>
      (Margarita Paz Castro, Pontificia Universidad Católica de Chile)
    </p>      
    
    <p>
      Decision diagrams (DDs) are graphical structures that can
      encode complex combinatorial problems as network flow
      problems. This talk explains how to leverage this network flow
      reformulation to create valid inequalities for integer
      programming problems. We review the main components behind
      several cutting plane algorithms based on DDs and present
      recent advances in the field.
    </p>
</ul>


<h2>MIAO seminars autumn 2022</h2>

  <ul>

    <li>
      <p>
	Monday Nov 7 at 14:00
	in seminar room E:2116, Ole Römers väg 3, Lund University,
	and on Zoom
	<br>
	<strong>
	  The shortest even cycle problem is tractable
	</strong>
	(<a href="https://youtu.be/daL3hDYbuXE">video</a>)
	<br>
	(Thore Husfeldt,  IT University of Copenhagen and Lund University)
      </p>      
      
      <p>
	Given a directed graph as input, we show how to efficiently find a
	shortest (directed, simple) cycle on an even number of vertices. As
	far as we know, no polynomial-time algorithm was previously known
	for this problem. In fact, finding any even cycle in a directed
	graph in polynomial time was open for more than two decades until
	Robertson, Seymour, and Thomas (Ann. of Math. (2) 1999) and,
	independently, McCuaig (Electron. J. Combin. 2004; announced jointly
	at STOC 1997) gave an efficiently testable structural
	characterisation of even-cycle-free directed graphs.
      </p>

      <p>
	Almost no knowledge of graph algorithms is necessary to
	appreciate the result. The second hour will be more about
	algebra and combinatorics than algorithms &mdash; polynomials,
	matrix functions, and generating functions.
      </p>
      
      <p>
	This is joint work with Andreas Björklund (Lund) and Petteri Kaski (Helsinki).
      </p>      


  <li>
    <p>
      Tuesday Oct 18 at 14:00 at
      DIKU øv-3-0-25, Universitetsparken 1, 
      University of Copenhagen and on Zoom
      <br>
      <strong>
	Exponential separations using guarded extension variables
      </strong>
      (<a href="https://youtu.be/qT2MYuN9J3o">video</a>)      
      <br>
      (Emre Yolcu, Carnegie Mellon University)
    </p>          
    
    <p>
      I will talk about the complexity of proof systems augmenting
      resolution with inference rules that allow, given a formula <em>F</em>
      in conjunctive normal form, deriving clauses that are not
      necessarily logically implied by <em>F</em> but whose addition to <em>F</em>
      preserves satisfiability.  When the derived clauses are
      allowed to introduce variables not occurring in <em>F</em>, the systems
      we will consider become equivalent to extended resolution. We
      are concerned with the versions of these systems "without new
      variables." They are called BC-, RAT-, SBC-, and GER-,
      denoting respectively blocked clauses, resolution asymmetric
      tautologies, set-blocked clauses, and generalized extended
      resolution. Each of these systems formalizes some restricted
      version of the ability to make assumptions that hold "without
      loss of generality," which is commonly used informally to
      simplify or shorten proofs. Except for SBC-, these systems are
      known to be exponentially weaker than extended
      resolution. They are, however, all equivalent to it under a
      relaxed notion of simulation that allows the translation of
      the formula along with the proof when moving between proof
      systems. I will show how to take advantage of this fact to
      construct formulas that separate RAT- from GER- and vice
      versa. With a similar strategy, we can also separate SBC- from
      RAT-. Additionally, I will briefly describe polynomial-size
      SBC- proofs of the pigeonhole principle, which separates SBC-
      from GER- by a previously known lower bound. These results
      also separate the three systems from BC- since they all
      simulate it. We thus obtain an almost complete picture of
      their relative strengths.
    </p>
    
    
  <li>
    <p>
      Wednesday Oct 5 at 14:00
      in seminar room E:2116, Ole Römers väg 3, Lund University,
      and on Zoom
      <br>
      <strong>
	Theoretical barriers for efficient proof search 
      </strong>
      (<a href="https://youtu.be/iqkb769GctM">video</a> of first half of seminar)          
      <br>
      (Susanna F. de Rezende, Lund University)
    </p>      
    
    <p>
      The proof search problem is a central question in automated
      theorem proving and SAT solving. Clearly, if a propositional
      tautology F does not have a short (polynomial size) proof in a
      proof system P, any algorithm that searches for P-proofs of F
      will necessarily take super-polynomial time. But can proofs of
      "easy" formulas, i.e., those that have polynomial size proofs,
      be found in polynomial time? This question motivates the study
      of automatability of proof systems. In this talk, we give an
      overview of known non-automatability results, focusing on the
      more recent ones, and present some of the main ideas used to
      obtain them.
    </p>
      

  <li>
    <p>
      Tuesday Oct 4 at 14:00 at University of Copenhagen and on Zoom
      <br>
      <strong>
	Matrix multiplication and polynomial identity testing
      </strong>
      (<a href="https://youtu.be/pu-2E5P1qgA">video</a>)                
      <br>
      (Robert Andrews, University of Illinois Urbana-Champaign)
    </p>      
    
    <p>
      Determining the complexity of matrix multiplication is a
      fundamental problem of theoretical computer science. It is
      popularly conjectured that &omega;, the matrix multiplication
      exponent, equals 2. If true, this conjecture would yield fast
      algorithms for a wide array of problems in linear algebra and
      beyond. But what if &omega; &gt; 2? In this talk, I will
      describe how lower bounds on &omega; can be used to make
      progress on derandomizing polynomial identity testing.
    </p>
    
  <li>
    <p>
      Friday Sep 30 at 14:00 on Zoom
      <br>
      <strong>
	Towards an algorithmic theory of proof complexity
      </strong>      
      (<a href="https://youtu.be/6FFgzOeI5pI">video</a> of first half of seminar)  
      <br>
      (Albert Atserias, Universitat Politècnica de Catalunya) 
    </p>      
    
    <p>
      A possibly unexpected by-product of the mathematical study of the
      lengths of proofs, as is done in the field of propositional proof
      complexity, is, I claim, that it may lead to new algorithmic
      insights. To explain this, I will first recall the origins of
      proof complexity as a field. Then I will explain why our current
      understanding of certain proof systems could lead to new
      algorithms. The key to this is that, for several proof systems of
      practical use, the class of tautologies with low-complexity proofs
      comes with a tight semantic characterization. Concretely, the
      characterization states that a tautology fails to have a
      low-complexity proof precisely when it is locally falsifiable, in
      a precise technical sense of the term. One immediate derivative of
      this is that, for those proof systems that admit such semantic
      characterizations, the statement that a formula has a
      low-complexity proofs has: (1) low-complexity certificates when
      true, and (2) low-complexity refutations when false. We illustrate
      the point by discussing the recently discovered
      subexponential-time algorithm that distinguishes the graphs that
      are 3-colorable from those that are not even n^eps-colorable in
      time exp(n^{1-2eps}), which beats all previously known approaches.	
    </p>
    
    
  <li>
    <p>
      Monday Sep 19 at 14:00 on Zoom
      <br>
      <strong>
	On vanishing sums of roots of unity in polynomial calculus and sum-of-squares
      </strong>
      (<a href="https://youtu.be/ZiKGlv994I8">video</a> of first half of seminar)                
      <br>
      (Ilario Bonacina, Universitat Politècnica de Catalunya) 
    </p>
    
    <p>
      Vanishing sums of roots of unity can be seen as a natural
      generalization of knapsack from Boolean variables to variables taking
      values over the roots of unity. We show that these sums are hard to
      prove for polynomial calculus and for sum-of-squares, both in terms of
      degree and size.  This talk is based on a joint work with M. Lauria
      and N. Galesi.
    </p>
    
    
</ul>

<h2>MIAO seminars spring 2022</h2>
  
  <ul>

    <li>
      <p>
	Wednesday Jun 8 at 14:00
	in seminar room E:2116, Ole Römers väg 3, Lund University
	<br>
	<strong>
	  Short proofs in strong proof systems
	</strong>
	<br>
	(Marijn Heule, Carnegie Mellon University)
      </p>      
      
      <p>
	The success of satisfiability solving presents us with an
	interesting peculiarity: modern solvers can frequently handle
	gigantic formulas while failing miserably on supposedly easy
	problems. Their poor performance is typically caused by the
	weakness of their underlying proof system&mdash;resolution. To
	overcome this obstacle, we need solvers that are based on
	stronger proof systems. Unfortunately, existing strong proof
	systems&mdash;such as extended resolution or Frege systems&mdash;do not
	seem to lend themselves to mechanization.
      </p>
      
      <p>
	In this talk, we discuss some recently proposed strong proof
	systems that are more suitable for mechanization. These proof
	systems are surprisingly strong, even without the introduction
	of new variables&mdash;a key feature of short proofs presented in
	the proof-complexity literature. We demonstrate the strength
	of these proof systems on two famous problems: the pigeonhole
	principle and mutilated chessboards.  For both problems, we
	present proofs of linear size without new variables. We also
	present a novel technique to find such proofs automatically
	and show its usefulness on SAT Competition benchmarks.  We
	conclude with some theoretical and practical challenges.	
    </p>

    <li>
      <p>
	Wednesday Jun 1 at 14:00 
	in Auditorium No. 2, Hans Christian Ørsted Building,
	Universitetsparken 5, University of Copenhagen,
	and on Zoom
	<br>
	<strong>
	  Certifying correctness for combinatorial algorithms by using pseudo-Boolean reasoning
	</strong>
	(<a href="https://youtu.be/N0BRDQ3C0jA">video</a>)	
	
	<br>
	(Stephan Gocht, Lund University and University of Copenhagen)
      </p>      

      <p>
	Although solving NP-complete problems is widely believed to
	require exponential time in the worst case, state-of-the-art
	algorithms are amazingly efficient for many NP-hard
	optimisation problems. However, this is achieved through
	highly sophisticated algorithms that are prone to
	implementation errors which can cause incorrect results, even
	for the best commercial tools. A promising approach to address
	this problem is to use certifying algorithms that produce not
	only the desired output but also a simple, machine-verifiable
	certificate or proof of correctness of the output. By
	verifying this proof with an external tool, we can guarantee
	that the given answer is valid.
      </p>      

      <p>
	This talk will give an introduction to a new proof system that can
	certify answers of algorithms for various combinatorial
	problems, such as Boolean satisfiability (SAT) solving and
	optimisation, constraint programming, and graph solving. This
	proof system operates on 0-1 integer linear constraints,
	generalising the cutting planes proof system. As a running
	example, we will show how to certify the correctness of a
	maximum matching algorithm.
      </p>      

      <p>
	After the official seminar, there will be an optional second
	part with more technical discussions. This second part will
	demonstrate how to generate such machine-verifiable proofs in
	practice and how to check them using the verifier VeriPB,
	which I developed during my PhD project.
      </p>
        
    <li>
      <p>
	Monday May 30 at 14:00
	in seminar room E:2116, Ole Römers väg 3, Lund University,
	and on Zoom	
	<br>
	<strong>
	  CDCL versus resolution
	</strong>
	(<a href="https://youtu.be/Pxi9QKczDKU">video</a>)	
	<br>
	(Marc Vinyals)
      </p>      
      
      <p>
	The effectiveness of the CDCL algorithm, the one most used to solve SAT in
	practice, is complicated to understand, and so far one of the most
	successful tools for that has been proof complexity. CDCL is easily
	seen to be limited by the resolution proof system, and furthermore it
	has been shown to be equivalent to resolution, in the sense that CDCL can
	reproduce a given resolution proof with only polynomial overhead.
      </p>
      
      <p>      
	But the question of the power of CDCL with respect to resolution is
	far from closed. To begin with, the previous equivalence is subject to
	some assumptions, only some of which are reasonable in practice. In
	addition, in a world where algorithms are expected to run in linear
	time, a polynomial overhead is too coarse a measure.
      </p>
      
      <p>      
	In this talk we will discuss what breaks when we try to make the
	assumptions more realistic, and how much of an overhead CDCL needs in
	order to simulate resolution.	
      </p>
	
    <li>
      <p>
	Tuesday Mar 22 at 14:00
	in seminar room A107,
	Hans Christian Ørsted Building,	Universitetsparken 5, University of Copenhagen,
	and on Zoom	
	<br>
	<strong>
	  Solving large scale instances of a geometric set cover problem with coloring conflicts
	</strong>
	(<a href="https://youtu.be/awah3rO32RQ">video</a> of first half of seminar)    	
	<br>
	(Allan Sapucaia, University of Campinas)
      </p>
      
      <p>
	When designing wireless networks, one wants to install
	antennas ensuring that all important regions are
	covered. There are many different secondary goals to consider
	such as minimizing the number of antennas, or ensuring that
	the network can still work even when some of the antennas are
	down.
      </p>
      
      <p>
	In this talk, we will discuss a geometric wireless network
	design problem where we want to minimize the number of
	antennas, while constrained by frequency assignment
	conflicts. We will study a Integer Linear Program model for
	this problem, and discuss how it can be improved using both
	its geometric and graph-theoretical aspects. We show that the
	problem can be efficiently solved in practice using
	decomposition and conclude by providing theoretical
	explanations for its performance.
      </p>

  </ul>

  <h2>MIAO seminars autumn 2021</h2>

<ul>
  <li>
    <p>
      Monday Dec 6 at 17:00 <em>(note the time!)</em>
      <br>
      <strong>
	Core-guided minimal correction set and core enumeration
      </strong>
      (<a href="https://youtu.be/7zUPCJQVjfQ">video</a>)
      <br>
      (Nina Narodytska, VMware Research)
    </p>      

    <p>
      A set of constraints is unsatisfiable if there is no solution
      that satisfies these constraints. To analyze unsatisfiable
      problems, the user needs to understand where inconsistencies
      come from and how they can be repaired. Minimal unsatisfiable
      cores and correction sets are important subsets of constraints
      that enable such analysis. In the first part of the talk, we
      analyze core-guided MaxSAT algorithms and discuss how the cores
      found by these algorithms are related to the cores of the
      original unsatisfiable formula. Based on these results, in the
      second part, we discuss a new algorithm for extracting minimal
      unsatisfiable cores and correction sets. Our new solver
      significantly outperforms several state of the art algorithms on
      common benchmarks when it comes to extracting correction sets
      and compares favorably on core extraction.
    </p>
    
  <li>
    <p>
      Monday Nov 22 at 14:00
      <br>
      <strong>
	TFNP: Collapses, separations, and characterisations
      </strong>
      (<a href="https://youtu.be/KKABxMxoOnE">video</a>)
      <br>
      (Mika Göös, EPFL)
    </p>      

    <p>
      We discuss a range of results for total NP search problem classes (<em>TFNP</em>)
      that includes new collapses of classes, black-box separations, and
      characterisations using propositional proof systems. We will focus on a
      surprising collapse result, <em>EoPL</em> = <em>PLS</em> &cap; <em>PPAD</em>, and see its full proof.
    </p>

    <p>
      Joint work with Alexandros Hollender, Siddhartha Jain, Gilbert
      Maystre, William Pires, Robert Robere, and Ran Tao.
    </p>


  <li>
    <p>
      Wednesday Nov 17 at 14:00
      in E:1408, Ole Römers väg 3, Lund University and on Zoom
      <br>
      <strong>
	Decomposition approaches for a large-scale scheduling problem
      </strong>
      (<a href="https://youtu.be/d8WFdJT0_0w">video</a> of first half of seminar)
      
      <br>
      (Elina Rönnberg, Linköping University)
    </p>

    <p>
      Generic state-of-the-art solvers for discrete optimisation are
      exceptionally powerful tools that efficiently solve a variety of
      problems. However, the scale and complexity of practically
      relevant problems can sometimes render these solvers incapable
      of even finding feasible solutions. In such cases, one
      possibility is to develop solution approaches that exploit
      problem structure to decompose the problem and then use the
      generic solvers for addressing the resulting subproblems. The
      success of such approaches relies on that the subproblems can be
      efficiently solved and that the information gained from that is
      sufficient to solve the original problem.
    </p>

    <p>
      In an industry-academia collaboration between Linköping
      University and Saab Aeronautics, we address the scheduling of a
      kind of electronic systems in future aircraft. Briefly, this
      problem can be described as a rich multiprocessor scheduling
      problem that also includes the scheduling of a communication
      network. To find feasible solutions to practically relevant
      instances of this problem is challenging.
    </p>

    <p>
      In this talk, I will present two different ways of decomposing
      the problem. The first relies on making a strong relaxation of
      the problem and then applying a constraint generation
      procedure. In this approach, both the relaxed problem and the
      subproblem are solved by a mixed-integer programming solver. The
      performance of the method is enhanced by an integration with
      adaptive large neighbourhood search. The second decomposition
      strategy is based on logic-based Benders decomposition. In this
      case, the master problem is solved as a mixed-integer program
      and the subproblem is formulated as a constraint program. The
      computational results from the two approaches are compared. To
      conclude the talk, the different ways of exploiting the problem
      structure and efficiency of solvers will be discussed and we
      will compare the properties of the resulting decomposition
      approaches.
    </p>
    


  
  <li>
    <p>
      <em> Joint <a href="https://barc.ku.dk/">BARC</a>/<a href="http://www.jakobnordstrom.se/miao-group/">MIAO</a> seminar:</em> <br>
      Friday Nov 12 at 14:00
      in Auditorium No. 10, Hans Christian Ørsted Building,
      Universitetsparken 5, University of Copenhagen,
      and on Zoom
      <br>
      <strong>
	Superpolynomial lower bounds against low-depth algebraic circuits    
      </strong>
      (<a href="https://youtu.be/qt2PkpZ95pc">video</a>)	  
      <br>
      (Nutan Limaye, IT University of Copenhagen)
    </p>

    <p>
      Every multivariate polynomial <em>P(X)</em> can be written as a sum
      of monomials, i.e. a sum of products of variables and field constants.
      In general, the size of such an expression is the number of monomials
      that have a non-zero coefficient in <em>P</em>.
    </p>

    <p>
      What happens if we add another layer of complexity, and consider sums
      of products of sums (of variables and field constants) expressions?
      Now, it becomes unclear how to prove that a given polynomial
      <em>P(X)</em> does not have small expressions. In this result, we
      solve exactly this problem.
    </p>

    <p>
      More precisely, we prove that certain explicit polynomials have no
      polynomial-sized "Sigma-Pi-Sigma" (sums of products of sums)
      representations. We can also show similar results for
      Sigma-Pi-Sigma-Pi, Sigma-Pi-Sigma-Pi-Sigma and so on for all
      "constant-depth" expressions.
    </p>

    <p>
      In the first part of this two-part talk, I will present the statements of the main results
      and some background. In the second part of the talk, I will give some proof
      details. 
    </p>

    <p>
      This is a joint work with Srikanth Srinivasan and S&eacute;bastien Tavenas.
    </p>
    

  <li>
    <p>
      Monday Nov 8 at 14:00
      <br>
      <strong>
	Lifting with inner-product and other low discrepancy gadgets
      </strong>
      (<a href="https://youtu.be/P3QN7kStgUc">video</a>)	  
      <br>
      (Sajin Koroth, Simon Fraser University)
    </p>

    <p>
      Lifting theorems are a powerful technique that exports our
      understanding of a weak model of computation (usually query
      complexity) to a powerful model of computation (usually
      communication complexity). They have been instrumental in
      solving many open problems in diverse areas of theoretical
      computer science like communication complexity, circuit
      complexity, proof complexity, linear programming, game theory,
      etc. A typical lifting theorem connects the complexity of
      computing <em>any</em> function <em>f</em> in the weak model to computing an
      associated function <em>f</em> &compfn; <em>g</em> in the powerful model. The associated
      function <em>f</em> &compfn; <em>g</em> is obtained by composing <em>f</em> with a specific function
      <em>g</em> known as the <em>gadget</em>. A key aspect of broad applicability and
      success of the lifting theorems is that they work for any <em>f</em>. In
      a typical lifting theorem, this universality is achieved by
      designing the gadget <em>g</em> with specific properties. The
      applicability of a lifting theorem is usually limited by the
      choice of gadget <em>g</em> and the size of the gadget.  Thus, it is
      crucial to understand what functions <em>g</em> can be used as a gadget
      and how small <em>g</em> can be. In this talk, we present a lifting theorem
      that connects query complexity to communication complexity and
      works for almost all gadgets <em>g</em> of "smallish" size.
    </p>

    <p>
      This talk is based on joint work with Arkadev Chattopadhyay, Yuval Filmus, Or Meir, and Toniann Pitassi.      
    </p>



  <li>
    <p>
      Monday Oct 25 at 14:00
      <br>
      <strong>
	Proof complexity lower bounds by composition
      </strong>
      (<a href="https://youtu.be/YysGGVwU8RU">video</a>)	    
      <br>
      (Robert Robere, McGill University)
    </p>      

    <p>
    In recent years, there has been an explosion in the development of
    so-called "lifting theorems" in proof complexity and other closely
    related areas which have led to the resolution of many
    long-standing open problems. The basic idea of a lifting theorem
    is simple: in order to prove a lower bound in a "complicated"
    system that we do not understand (for example, Cutting Planes
    refutations), we will "escalate" the hardness from a "simple"
    system that we do understand (for example, Resolution refutations)
    by taking a hard formula F for the simple system and composing it
    with a specially chosen "gadget function" that removes the power
    of the complicated system. In many cases, it is possible to prove
    that the "best" possible strategy in the complicated system for
    refuting the composed formula is to simulate the proof of the
    uncomposed formula in the simple system (and thus lower bounds for
    the uncomposed formula are "escalated" or "lifted" to lower bounds
    for the composed formula). While lifting theorems in circuit
    complexity can be traced back to the work of Raz and McKenzie
    [RM99], recent developments have pushed these techniques to many
    new areas, and have shown how lifting is a flexible tool that
    allows quite finely tuned tradeoffs between different parameters
    for a wide variety of proof systems.
    </p>

    <p>
      In this talk, we give an introduction to and survey of lifting
      results in proof complexity and related fields, like
      communication complexity and circuit complexity, and outline
      some of the ways that lifting can be used to control various
      "complexity parameters" of unsatisfiable CNF formulas (like
      proof length, proof space, proof depth, etc.). We will highlight
      several recent developments in the area and indicate some future
      directions.
    </p>
    
  <li>
    <p>
      Friday Oct 22 at 14:00
      <br>
      <strong>
	Verified proof checkers
      </strong>
      (<a href="https://youtu.be/lXTAECUZdQQ">video</a>)	      	 
      <br>
      (Magnus Myreen, Chalmers University of Technology)
    </p>

    <p>
      Solvers, such as e.g. SAT solvers, are often complicated pieces
      of software. How can we trust their results? For highly
      optimised state-of-the-art solvers, testing is insufficient and
      proving the functional correctness of the solver's
      implementation is not practically possible. Fortunately, solvers
      can often be augmented to produce proof certificates that can be
      checked by separate simpler proof checkers. In recent years,
      there has been growing interest in formally proving that the
      proof checkers will never accept a certificate that contains
      flaws.      
    </p>

    
    <p>
      In this talk, I will describe work that makes it possible to
      prove functional correctness of proof checkers down to the
      machine code that runs them. I have worked on (and have
      supervised work on) several checkers. In this talk, I'll focus
      on (1) my work on proving end-to-end correctness of Jared
      Davis's Milawa prover, and (2) recent work on a LPR/LRAT checker
      for UNSAT proofs. My talk will include a description of the
      CakeML project, which was the context of (2). I will use demos
      to show what the tools look like when running.
    </p>

  <li>
    <p>
      Friday Oct 15 at 10:00
      <br>
      <strong>
	Logic-based explainable AI
      </strong>
      (<a href="https://youtu.be/epDu9ZcCCG0">video</a>)	      	 
      <br>
      (Alexey Ignatiev, Monash University)      
    </p>      

    <p>
      Explainable artificial intelligence (XAI) represents arguably
      one of the most crucial challenges being faced by the area of AI
      these days. Although the majority of approaches to XAI are of
      heuristic nature, recent work proposed the use of abductive
      reasoning to computing provably correct explanations for machine
      learning (ML) predictions. The proposed rigorous approach was
      shown to be useful not only for computing trustable explanations
      but also for reasoning about explanations computed
      heuristically. It was also applied to uncover a close
      relationship between XAI and verification of ML models. This
      talk will overview the advances of the rigorous logic-based
      approach to XAI as well as the use of reasoning in devising
      interpretable rule-based ML models including decision trees,
      decision sets, and decision lists.
      </p>
    
    <li>
    <p>
      Monday Oct 4 at 14:00
      <br>
      <strong>
	Monotone arithmetic lower bounds via communication complexity
      </strong>
      (<a href="https://youtu.be/TOaqhxI15CI">video</a>)	      
      <br>
      (Arkadev Chattopadhyay, Tata Institute of Fundamental Research, Mumbai)
    </p>

    <p>
      How much power does negation or cancellation provide to
      computation?  This is a fundamental question in theoretical
      computer science that appears in various parts: in Boolean
      circuits, arithmetic circuits and also in communication
      complexity. I will talk about some new connections between the
      latter two fields and their applications to extend two classical
      results from four decades ago:

      <ol>
	<li>
	  Valiant (1979) showed that monotone arithmetic circuits are
	  exponentially weaker than general circuits for computing
	  monotone polynomials. Our first result gives a qualitatively
	  more powerful separation by showing an exponential separation
	  between general monotone circuits and constant-depth
	  multi-linear formulas. Neither such a separation between general
	  formulas and monotone circuits, nor a separation between
	  multi-linear circuits and monotone circuits were known
	  before. Our result uses the recent counter-example to the
	  Log-Approximate-Rank Conjecture in communication complexity.
	  
	<li>
	  Jerrum and Snir (1982) also obtained a separation between the
	  powers of general circuits and monotone ones via a different
	  polynomial, i.e. the spanning tree polynomial (STP), a
	  polynomial that is well known to be in
	  <em>VP</em>, using non-multi-linear cancellations of determinantal
	  computation.  We provide the first extension of this result to show
	  that the STP remains "robustly hard" for monotone circuits in the
	  sense of Hrubes' recent notion of epsilon-sensitivity. The latter
	  result is proved via formulating a discrepancy method for monotone
	  arithmetic circuits that seems independently interesting.
      </ol>
    </p>
    
    <p>
      We will discuss several open problems arising from these results.
      
      (The seminar is based on joint works with Rajit Datta, Utsab Ghosal and
      Partha Mukhopadhyay.)
    </p>
    

  <li>
    <p>
      Monday Sep 20 at 14:00
      <br>
      <strong>
	KRW composition theorems via lifting
      </strong>
      (<a href="https://youtu.be/zXTTc5aq0j4">video</a>)	      
      <br>
      (Or Meir, University of Haifa)
    </p>
    
    <p>
      One of the major open problems in complexity theory is proving
      super-logarithmic lower bounds on the depth of circuits (i.e., separating
      <em>P</em> from <em>NC</em><sup>0</sup>).
      Karchmer, Raz, and Wigderson (Computational
      Complexity 5(3/4), 1995) suggested approaching this problem by proving
      that depth complexity behaves "as expected" with respect to 
      composition of functions. They showed that the validity of this
      conjecture would separate
      <em>P</em> from <em>NC</em><sup>0</sup>.
      Several works have made
      progress toward resolving this conjecture by proving special cases. In
      particular, these works proved the KRW conjecture for every outer
      function, but only for few inner functions.  Thus, it is an important
      challenge to prove the KRW conjecture for a wider range of inner
      functions.
    </p>
    
    <p>      
      In this work, we extend significantly the range of inner
      functions that can be handled. First, we consider the monotone
      version of the KRW conjecture. We prove it for every monotone
      inner function whose depth complexity can be lower bounded via a
      query-to-communication lifting theorem. This allows us to handle
      several new and well-studied functions such as the
      <em>s</em>-<em>t</em>-connectivity, clique, and generation functions.
    </p>
    
    <p>
      In order to carry this progress back to the non-monotone
      setting,we introduce a new notion of semi-monotone composition,
      which combines the non-monotone complexity of the outer function
      with the monotone complexity of the inner function. In this
      setting, we prove the KRW conjecture for a similar selection of
      inner functions, but only for a specific choice of the outer
      function.
    </p>
  

  <li>
    <p>
      Friday Sep 17 at 14:15  <br>
      <strong>
	Estimating the size of unions of sets in streaming model
      </strong>
      (<a href="https://youtu.be/3QZpbBFCzCQ">video</a>)	
      <br>
      (Kuldeep S. Meel, National University of Singapore)
    </p>

    <p>
      Feeling tired of complicated theorems with complicated proofs?
      Fret not; this week will be different: A simple theorem with a simpler
      proof for a general problem. I will make a case for our PODS-21 paper
      to be the simplest paper ever accepted at PODS.
    </p>
    
    <p>
      A set is Delphic if it supports efficient membership, sampling, and
      counting calls. The notion of Delphic sets captures several well-known
      problems, such as Klee's measure, distinct elements, and model
      counting of DNF formulas.  We will discuss estimation of the size of
      the union of Delphic sets wherein each set is implicitly (and
      succinctly) represented, and comes in a streaming fashion.
    </p>
    
    <p>
      The primary contribution of our work is a simple, elegant, and
      efficient sampling-based algorithm for the estimation of the union in
      the streaming setting. Our algorithm has worst case space
      complexity and update time that is logarithmic in the size of the
      universe and stream size. Consequently, our algorithm provides the
      first algorithm with a linear dependence on <em>d</em> for Klee's measure
      problem in streaming setting for <em>d>1</em>, thereby settling the open
      problem of Woodruff and Tirthpura (PODS-12). The Klee's measure
      problem corresponds to computation of volume of multi-dimension
      axis-aligned rectangles, i.e., every <em>d</em>-dimension axis-aligned
      rectangle can be defined as <em>[a_1,b_1]</em> x <em>[a_2,b_2]</em> x &hellip; x <em>[a_d, b_d]</em>.
    </p>
    
    <p>
      (Joint work with N.V. Vinodchandran and Sourav Chakraborty.)
    </p>
    
    <li>
    <p>
      Monday Sep 6 at 14:00
      <br>
      <strong>
	Lifting with sunflowers
      </strong>
      (<a href="https://youtu.be/NRFZekCsG1I">video</a>)	
      <br>
      (Ian Mertz, University of Toronto)
    </p>
    
    <p>
      Lifting theorems are an important class of techniques which
      can transform functions which are hard for weak computation
      models into functions which are hard for strong computation
      models. Starting with Raz and McKenzie (1999), there has been
      a flurry of work proving query-to-communication lifting
      theorems, which translate lower bounds on query complexity to
      lower bounds for the corresponding communication model. In
      this talk I will present a simplified proof of deterministic
      query-to-communication lifting. Our proof uses elementary
      counting together with a novel connection to the sunflower
      lemma.	
    </p>


  <li>
    <p>
      Friday Aug 27 at 10:00
      <br>
      <strong>
	Who is Isabelle, and why is she so picky about my proofs?
      </strong>
      <br>
      (Dmitriy Traytel, University of Copenhagen)
    </p>
    
    <p>
      Proof assistants are tools that mechanically check human-written formal proofs,
      e.g., of an algorithm's correctness, and support their users in developing
      these proofs. Landmark achievements in this area include realistic verified
      compilers, operating system kernels, and distributed systems as well as formal
      proofs of deep mathematical results such as the four color theorem, the
      Feit–Thompson theorem, and the Kepler conjecture. In this talk, I will give a
      brief introduction of the Isabelle/HOL proof assistant, of which I am both a user
      and a developer. I will explain how Isabelle's foundational approach achieves
      the highest level of trustworthiness and will examplify the benefits of using a
      proof assistant via three case studies: the formal verification of security
      properties of authenticated data structures, the completeness of ordered
      resolution, and the correctness of an efficient runtime monitoring algorithm.
    </p>
      
</ul>

    

  <h2>MIAO seminars spring 2021</h2>
  

<p>
    
  <em>
    During the spring semester of 2021,
    we had    online virtual seminars running every weekday
    at 17:30 CET from early February to mid-May
    as part of the 
    <a href="https://simons.berkeley.edu/programs/sat2021">Satisfiability: Theory, Practice, and Beyond</a>
    and
    <a href="https://simons.berkeley.edu/programs/tfcs2021">Theoretical Foundations of Computer Systems</a>
    programs
    at the
    <a href="https://simons.berkeley.edu/">Simons Institute
      for the Theory of Computing</a>.

    On top of this, we had some additional seminars as listed
    below.
  </em>

</p>
  
<ul>
    
    <li>
      <p>
	Monday Jun 7 at 14:00
	<br>
	<strong>
	  Proof complexity meets finite model theory
	</strong>
	(<a href="https://youtu.be/0P0N7ucxFg4">video</a>)	
	<br>
	(Joanna Ochremiak, LaBRI, Université de Bordeaux and CNRS)
      </p>      

      <p>
	Finite model theory studies the power of logics on the class of finite 
structures. One of its goals is to characterize symmetric computation, 
that is, computation that abstracts away details which are not essential
 for the given task, by respecting the symmetries of the input.
      </p>
      
      <p>
	In this talk I will discuss connections between proof complexity and 
finite model theory, focussing on lower bounds. For certain proof 
systems, the existence of a succinct refutation can be decided in a 
symmetry-preserving way. This allows us to transfer lower bounds from 
finite model theory to proof complexity. I will introduce this approach 
and explain its key technical ideas such as the method of folding for 
dealing with symmetries in linear programs.
      </p>


        </li><li>
      <p>
	Friday Jun 4 at 14:00
	<br>
	<strong>
	Abstract cores in implicit hitting set based MaxSAT solving
	</strong>

	(<a href="https://youtu.be/rDz1iVO5Yjg">video</a>)
	<br>
	(Jeremias Berg, University of Helsinki) 
      </p>

      <p>
	Maximum satisfiability (MaxSat) solving is an active area of research 
motivated by numerous successful applications to solving NP-hard 
combinatorial optimization problems. One of the most successful 
approaches for solving MaxSat instances from real world domains are the 
so called implicit hitting set (IHS) solvers. IHS solvers decouple 
MaxSat solving into separate core-extraction and optimization steps 
which are tackled by an Boolean satisfiability (SAT) and an integer 
linear programming (IP) solver, respectively. While the approach shows 
state-of-the-art performance on many industrial instances, it is known 
that there exists instances on which IHS solvers need to extract an 
exponential number of cores before terminating. In this talk I will 
present the  simplest of these problematic instances
	and talk about how abstract cores, a compact representation of a large 
number of regular cores that we recently proposed, addresses perhaps the
 main bottleneck of IHS solvers. I will show how to incorporate abstract
 core reasoning into the IHS algorithm and demonstrate that
	 that including abstract cores into a state-of-the- art IHS solver 
improves its performance enough to surpass the best performing solvers 
of the recent MaxSat Evaluations.
	</p>
      
          
    </li><li>
      <p>
	Friday May 28 at 14:00
	<br>
	<strong>
	  Feasible interpolation for algebraic proof systems
	</strong>
	(<a href="https://youtu.be/S8N3-089LQQ">video</a>)
	<br>
	(Tuomas Hakoniemi,
	Universitat Politècnica de Catalunya)
      </p>

      <p>
	In this talk we present a form of feasible interpolation for two 
algebraic proof systems, Polynomial Calculus and Sums-of-Squares. We 
show that for both systems there is a poly-time algorithm that given two
 sets <em>P(x,z)</em> and <em>Q(y,z)</em> of polynomial equalities, a refutation of the union of <em>P(x,z)</em> and <em>Q(y,z)</em> and an assignment <em>a</em> to the <em>z</em>-variables outputs either a refutation of <em>P(x,a)</em> or a refutation of <em>Q(y,a).</em>
 Our proofs are fairly logical in nature, in that they rely heavily on 
semantic characterizations of resource-bounded refutations to prove the 
existence of suitable refutations. These semantic existence proofs 
narrow down the search space for the refutations we are after so that we
 can actually find them efficiently.
	</p>
      
    </li><li>
      <p>
	Monday May 17 at 14:00
	<br>
	<strong>
	  Average-case perfect matching lower bounds
	  from hardness of Tseitin formulas	    
	</strong>
	(<a href="https://youtu.be/1Ha50m1p_Ck">video</a>)
	<br>
	(Kilian Risse, KTH Royal Institute of Technology)
      </p>
      
      
      <p>
	We study the complexity of proving that a sparse random regular
	graph on an odd number of vertices does not have a perfect matching,
	and related problems involving each vertex being matched some
	pre-specified number of times.
	We show that this requires proofs of degree &#937;(n / log n) in
	the Polynomial Calculus (over fields of characteristic &#8800; 2) and
	Sum-of-Squares proof systems, and exponential size in the
	bounded-depth Frege proof system.
	This resolves a question by Razborov asking whether
	the LovÃ¡sz-Schrijver proof system requires n<sup>&#948;</sup>
	rounds to refute these formulas for some &#948; &gt; 0.
	The results are obtained by a
	worst-case to average-case reduction of these formulas relying on a
	topological embedding theorem which may be of independent interest.
      </p>
      
      <p>Joint work with with Per Austrin.
      </p>
      
    
    </li><li>
      <p>
	Monday May 10 at 14:00
	<br>
	<strong>
	  On the complexity of branch and cut
	</strong>
	(<a href="https://youtu.be/WgfWXXW2BqA">video</a>)
	<br>
	(Noah Fleming, University of Toronto)
      </p>      
      
      <p>
	The Stabbing Planes proof system was introduced to model practical 
branch-and-cut integer programming solvers. As a proof system, Stabbing 
Planes can be viewed as a simple generalization of DPLL to reason about 
linear inequalities. It is powerful enough to simulate Cutting Planes 
and produce short refutations of the Tseitin formulas — certain 
unsatisfiable systems of linear equations mod 2 — which are canonical 
hard examples for many algebraic proof systems. In a surprising recent 
result, Dadush and Tiwari showed that these short Stabbing Planes 
refutations of the Tseitin formulas could be translated into Cutting 
Planes proofs. This raises the question of whether all Stabbing Planes 
can be efficiently translated into Cutting Planes. In recent work, we 
give a partial answer to this question.
      </p>
      
      <p>
	In this talk I will introduce and motivate the Stabbing Planes proof 
system. I will then show how Stabbing Planes proofs with 
quasi-polynomially bounded coefficients can be quasi-polynomially 
translated into Cutting Planes. As a consequence of this translation, we
 can show that Cutting Planes has quasi-polynomial size refutations of 
any unsatisfiable system of linear equations over a finite field. A 
remarkable property of our translation for systems of linear equations 
over finite fields, and the translation of Dadush and Tiwari for the 
Tseitin formulas, is that the resulting proofs are also 
quasi-polynomially deep. A natural question is thus whether these depth 
bounds can be improved. In the last part of the talk, I will discuss 
progress towards answering this question in the form of a new depth 
lower bound technique for Cutting Planes, which works also for the 
stronger semantic Cutting Planes system, and which allows us to 
establish the first linear lower bounds on the depth of semantic Cutting
 Planes refutations of the Tseitin formulas.
      </p>
      

    </li><li>
      <p>
	Monday May 3 at 14:00 <br>
	<strong>
	  SAT-encodings and scalability
	</strong>
	(<a href="https://youtu.be/tXIGe71yFwI">video</a>)
	<br> 
	(André Schidler, Technische Universität Wien)
      </p>
      
      <p>
	Boolean satisfiability (SAT) solvers have reached stunning performance 
over the last decade. This performance can be harnessed for other 
problems by means of SAT encodings: translating the problem instance 
into a SAT instance. SAT encodings have been used successfully for many 
combinatorial problems and are established in industry. In this talk, I 
discuss the general idea behind SAT encodings and two specific 
application areas: graph decompositions and machine learning.
      </p>
      
      <p>
	Graph decompositions allow for specialized algorithms that can solve 
hard problems efficiently. SAT encodings provide not only the means to 
optimally compute these decompositions, but can be easily extended by 
extra constraints specific to the hard problem to be solved.
      </p>

      <p>
	For machine learning, SAT encodings gained increased attention in 
recent years, as they allow the induction of very small AI models. 
Learning small models has become more important in the context of 
explainable AI: smaller models are usually easier to understand for 
humans. We will focus specifically on decision tree induction.
      </p>
      
      <p>
	Scalability is one of the main issues when using SAT encodings. We can 
overcome this problem by embedding SAT-based solving into a heuristic 
framework. This allows us to trade off a slightly worse result for large
 applicability. In the last part of our talk, we discuss our SAT-based 
local improvement framework that implements this idea.
	</p>

    </li><li>
      <p>
	Wednesday Apr 28 at 15:00
	<br>
	<strong>
	  Slicing the hypercube is not easy
	</strong>
	(<a href="https://youtu.be/arbxOTjsQZQ">video</a>)
	<br>
	(Amir Yehudayoff, Technion – Israel Institute of Technology)
      </p>
      
      <p>
	
	How many hyperplanes are needed to slice all edges of the hypercube? 
This question has been studied in machine learning, geometry and 
computational complexity since the 1970s. We shall describe (most of) an
 argument showing that more than <em>n</em><sup>0.57</sup> hyperplanes are needed, for large&nbsp;<em>n</em>. We shall also see a couple of applications. This is joint work with Gal Yehuda.
      </p>
      

    
    </li><li>
      <p>
	Monday Apr 26 at 14:00
	<br>
	<strong>
	  Recent lower bounds in algebraic complexity theory
	</strong>
	(<a href="https://youtu.be/1yRkXzmu8Hg">video</a>)
	<br>
	(Ben Lee Volk, University of Texas at Austin)
      </p>
      
      <p>
	Algebraic complexity theory studies the complexity of solving algebraic
 computational tasks using algebraic models of computation. One major 
problem in this area is to prove lower bounds on the number of 
arithmetic operations required for computing explicit polynomials. This 
natural mathematical problem is the algebraic analog of the famous <em>P</em> vs. <em>NP</em> problem. It also has tight connections to other classical mathematical areas and to fundamental questions in complexity theory.
      </p>
	
      <p>
	In this talk I will provide background and then present some recent 
progress on proving lower bounds for models of algebraic computation, 
such as the algebraic analogs of <em>NC</em><sup>1</sup> and <em>NL</em>.
      </p>
      
      <p>
	Based on joint works with Prerona Chatterjee, Mrinal Kumar, and Adrian She.
      </p>		
    
    </li><li>
	<p>
	  Friday Apr 23 at 14:00
	  <br>
	  <strong>
	    On the complexity of branching proofs
	  </strong>
	  (<a href="https://youtu.be/3wxIuNJp1Gw">video</a>)
	  <br>
	  (Daniel Dadush, CWI)
	</p>
	
	<p>
	  We consider the task of proving integer infeasibility of a bounded
	  convex <em>K</em> in <em>R<sup>n</sup></em> using a general branching
	  proof system. In a general branching proof, one constructs a branching
	  tree by adding an integer disjunction <em>ax &#10877; b</em> or
	  <em>ax &#10878; b+1</em>, for an integer vector <em>a</em> and an
	  integer <em>b</em>, at each node, such that the leaves of the tree
	  correspond to empty sets (i.e., <em>K</em> together with the
	  inequalities picked up from the root to leaf is empty). Recently,
	  Beame et al (ITCS 2018), asked whether the bit size of the
	  coefficients in a branching proof, which they named stabbing planes
	  (SP) refutations, for the case of polytopes derived from SAT formulas,
	  can be assumed to be polynomial in <em>n</em>. We resolve this
	  question by showing that any branching proof can be recompiled so that
	  the integer disjunctions have coefficients of size at most
	  <em>(nR)<sup>O(n2)</sup></em>, where <em>R</em> is the radius of an
	  <em>l<sub>1</sub></em> ball containing <em>K</em>,  while increasing
	  the number of nodes in the branching tree by at most a factor
	  <em>O(n)</em>. As our second contribution, we show that Tseitin
	  formulas, an important class of infeasible SAT instances, have
	  quasi-polynomial sized cutting plane (CP) refutations, disproving the
	  conjecture that Tseitin formulas are (exponentially) hard for CP. As
	  our final contribution, we give a simple family of polytopes in
	  <em>[0,1]<sup>n</sup></em> requiring branching proofs of length
	  <em>2<sup>n</sup>/n</em>.
	</p>
	
	<p>
	  Joint work with Samarth Tiwari.
	</p>
	

    
    </li><li>
      <p>
	Monday Apr 19 at 14:00
      <br>
      <strong>
	Kidney exchange programmes —
	saving lives with optimisation algorithms
      </strong>
      (<a href="https://youtu.be/6kQxq-EfVpQ">video</a>)
      <br>
      (William Pettersson, University of Glasgow)
      </p>

      <p>
	Kidney Exchange Programmes (KEPs) increase the rate of living
	donor kidney transplantation, in turn saving lives. In this
	talk, I will explain exactly what KEPs are, how KEPs achieve
	this goal, and the role of optimisation algorithms within
	KEPs. This will include brief explanations of some of the
	models used for kidney exchange programmes, some of the more
	generic optimisation techniques that we use, as well as recent
	advances and specific research directions for the field into
	the future. This talk will very much be an overview of kidney
	exchange, without going into complex details of optimisation
	algorithms, making it suitable for a wider audience.
      </p>
      
    
    </li><li>
      <p>
	Thursday Apr 8 at 14:00
      <br>
      <strong>
	(Semi)Algebraic proofs over {&pm;1} variables
      </strong>
      (<a href="https://youtu.be/trV7ilheKQg">video</a>)
      <br>
      (Dmitry Sokolov, St.Petersburg State University)
      </p>

      <p>
	One of the major open problems in proof complexity is to prove
	lower bounds on AC0[p]-Frege proof systems. As a step toward
	this goal Impagliazzo, Mouli and Pitassi in a recent paper
	suggested proving lower bounds on the size for Polynomial
	Calculus over the {&pm;1} basis. In this talk we show a
	technique for proving such lower bounds and moreover, we also
	give lower bounds on the size for Sum-of-Squares over the
	{&pm;1} basis.
      </p>

      <p>
	We discuss the difference between {0, 1} and {+1, -1} cases and
	problems in further generalizations of the lower bounds.
      </p>


    </li><li>
      <p>
      <em> Courtesy of Zuse Institute Berlin:</em> <br>
      Friday Feb 12 at 14:00
      <br>
      <strong>
	Introduction to IP presolving techniques in PaPILO
      </strong> <br>
      (Alexander Hoen, Zuse Institute Berlin)
      </p>

      <p>
  Presolving is an essential part contributing to the performance of
  modern MIP solvers. PaPILO, a new C++ library, provides presolving
  routines for MIP and LP problems. This talk will give an introduction
  to basic IP-presolving techniques and provide insights into important
  design choices enabling PaPILO's capabilities, in particular
  regarding its use of parallel hardware. While presolving itself is
  designed to be fast, this can come at the cost of failing to find
  important reductions due to working limits and heuristic filtering.
  Yet, even most commercial solvers do not use multi-threading for the
  preprocessing step as of today. PaPILO's design facilitates use of
  parallel hardware to allow for more aggressive presolving and
  presolving of huge problems. The architecture of PaPILO allows
  presolvers generally to run in parallel without requiring expensive
  copies of the problem and without special synchronization in the
  presolvers themselves. Additionally, the use of Intel's TBB library
  aids PaPILO to efficiently exploit recursive parallelism within
  expensive presolving routines, such as probing, dominated columns, or
  constraint sparsification. Despite PaPILO's use of parallelization,
  its results are guaranteed to be deterministic independently of the
  number of threads available.

      </p>

  </li></ul>
  
<h2>MIAO seminars autumn 2020</h2>


<p>
  
  </p><ul>

    <li>
      <p>
	Friday Oct 9 at 13:15 <br>
	<strong>
	  Model counting with probabilistic component caching
	</strong> <br>
	(Shubham Sharma and Kuldeep S. Meel,
	National University of Singapore)
      </p>

      <p>
	Given a Boolean formula F, the problem of model counting, also
	referred to as #SAT, seeks to compute the number of solutions of F.
	Model counting is a fundamental problem with a wide variety of
	applications ranging from planning, quantified information flow to
	probabilistic reasoning and the like. The modern #SAT solvers tend to
	be either based on static decomposition, dynamic decomposition, or a
	hybrid of the two. Despite dynamic decomposition based #SAT solvers
	sharing much of their architecture with SAT solvers, the core design
	and heuristics of dynamic decomposition-based #SAT solvers has
	remained constant for over a decade. In this paper, we revisit the
	architecture of the state-of-the-art dynamic decomposition-based #SAT
	tool, sharpSAT, and demonstrate that by introducing a new notion of
	probabilistic component caching and the usage of universal hashing
	for exact model counting along with the development of several new
	heuristics can lead to significant performance
	improvement over state-of-the-art model-counters. In particular, we
	develop GANAK, a new scalable probabilistic exact model counter that
	outperforms state-of-the-art exact and approximate model counters for
	a wide variety of instances.
      </p>

    </li><li>
      <p>
	Friday Sep 25 at 13:15 <br>
	<strong>
	  Manthan: A data-driven approach for Boolean function synthesis
	</strong> <br>
	(Priyanka Golia and Kuldeep S. Meel,
	National University of Singapore)
      </p>

      <p>
	Boolean functional synthesis is a fundamental problem in computer
	science with wide-ranging applications and has witnessed a surge of
	interest resulting in progressively improved techniques over the past
	decade. Despite intense algorithmic development, a large number of
	problems remain beyond the reach of the current state-of-the-art
	techniques. Motivated by the progress in machine learning, we propose
	Manthan, a novel data-driven approach to Boolean functional
	synthesis. Manthan views functional synthesis as a classification
	problem, relying on advances in constrained sampling for data
	generation, and advances in automated reasoning for a novel
	proof-guided refinement and provable verification. On an extensive
	and rigorous evaluation over 609 benchmarks, we demonstrate that
	Manthan significantly improves upon the current state of the art,
	solving 356 benchmarks in comparison to 280, which is the most solved
	by a state-of-the-art technique; thereby, we demonstrate an increase
	of 76 benchmarks over the current state of the art. The significant
	performance improvements, along with our detailed analysis, highlights
	several interesting avenues of future work at the intersection of
	machine learning, constrained sampling, and automated reasoning.
      </p>

      

    </li><li>
      <p>
	Friday Aug 28 at 13:15 <br>
	<strong>
	  Tuning Sat4j PB solvers for decision problems
	</strong> <br>
	(Romain Wallon,
	Université d'Artois)
      </p>
      <p>
	During the last decades, many improvements in CDCL SAT solvers have 
made possible to solve efficiently large problems containing millions of
 variables and clauses.
	Despite this practical efficiency, some instances remain out of reach 
for such solvers.
	This is particularly true when the input formula requires an 
exponential size refutation proof in the resolution proof system (as for
 pigeonhole formulae).
	This observation motivated the development of another kind of solvers, 
known as pseudo-Boolean (PB) solvers.
	These solvers take as inputs a conjunction of PB constraints (integral 
linear inequations over Boolean variables) and benefit from the cutting 
planes proof system, which is (in theory) stronger than the resolution 
proof system.
	To implement this proof system, current PB solvers follow the direction
 of modern SAT solvers, by implementing a conflict analysis procedure 
relying on the application of cutting planes rules.
	However, adapting the CDCL architecture to take into account PB 
constraints is not as straightforward as it may look.
	In particular, many CDCL invariants and properties do not hold anymore 
as long as PB constraints are considered.
	While some of them may be safely ignored (e.g., when they affect the 
decision heuristic, the deletion strategy or the restart policy), some 
others must be fixed to ensure the soundness of the solver (e.g., by 
ensuring to preserve the conflict during its analysis).
      </p>
      <p>	
	In this talk, we will give an overview of the main differences between 
PB solving and classical SAT solving, and present different approaches 
that have been designed to take these differences into account to extend
 the CDCL architecture to PB problems.
	We will in particular discuss the pros and cons of these approaches, 
and we will explain how they can be enhanced to improve the practical 
performance of PB solvers.
      </p>
      
    </li><li>
      <p>
	Friday Aug 21 at 10:15 <br>
	<strong>
	  Using proofs to analyze SAT solvers
	</strong> <br>
	(Janne Kokkala,
	Lund University and University of Copenhagen)
      </p>

      <p>

	The main idea of this seminar is to give an overview of what
	one can ask and what one can learn about SAT solvers when
	analyzing the proof to estimate what part of the work was
	useful. I will start by giving a 17-ish minute alpha test run
	for my presentation for our CP paper [1]. After that, I will
	discuss earlier works that use the same or a similar idea for
	general insights [2], analyzing VSIDS usefulness [3], and
	clause exchange for parallel solvers [4,5]. To conclude, we
	can discuss how this approach could be used for pseudo-Boolean
	solvers.
      </p>

      <p>
	[1] J. I. Kokkala, J. Nordström.
	    <a href="http://www.csc.kth.se/~jakobn/research/UsingProofs_CP.pdf">Using Resolution Proofs to
	      Analyse CDCL SAT solvers.</a>
	    
	  <br>	
	    [2] L. Simon.
	    <a href="https://pdfs.semanticscholar.org/2064/7856995db578bb90a9e9c5448304850d05f0.pdf">Post Mortem Analysis of SAT Solver Proofs.</a>
	    
	  <br>	
	    [3] S. Malik, V. Ying.
	    <a href="https://www.victoraying.com/talks/fields_2016_sat_efficiency.pdf">On the efficiency of the VSIDS decision heuristic.</a>
	    (Workshop presentation.)
	    
	    
	  <br>	
	    [4] G. Audemard, L. Simon.
	    <a href="http://www.cril.univ-artois.fr/articles/syrup.pdf">Lazy
	      clause exchange policy for parallel SAT solvers.</a>

	  <br>	
	    [5] G. Katsirelos, A. Sabharwal, H. Samulowitz, L. Simon.
	    <a href="https://miat.inrae.fr/katsirelos/papers/ksssaaai13.pdf">Resolution and parallelizability: Barriers to the efficient
	      parallelization of SAT solvers.</a>
	
      </p>
      
    </li><li>
      <p>
	Wednesday Aug 19 at 13:15 <br>
	<strong>
	  On computational aspects of the antibandwidth problem
	</strong> <br>
	(Markus Sinnl,
	Johannes Kepler University Linz)
      </p>

      <p>
	In this talk, we consider the antibandwidth problem, also
	known as dual bandwidth problem, separation problem and
	maximum differential coloring problem. Given a labeled graph
	(i.e., a numbering of the vertices of a graph), the
	antibandwidth of a node is defined as the minimum absolute
	difference of its labeling to the labeling of all its adjacent
	vertices. The goal in the antibandwidth problem is to find a
	labeling maximizing the antibandwidth. The problem is NP-hard
	in general graphs and has applications in diverse areas like
	scheduling, radio frequency assignment, obnoxious facility
	location and map-coloring.
      </p>

      <p>
	There has been much work on deriving theoretical bounds for
	the problem and also in the design of metaheuristics in recent
	years. However, the optimality gaps between the best known
	solution values and reported upper bounds for the
	HarwellBoeing Matrix-instances, which are the commonly used
	benchmark instances for this problem, were often very large
	(e.g., up to 577%).
      </p>

      <p>
	We present new mixed-integer programming approaches for the
	problem, including one approach, which does not directly
	formulate the problem as optimization problem, but as a series
	of feasibility problems. We also discuss how these feasibility
	problems can be encoded with various SAT-encodings, including
	a new and specialised encoding which exploits a certain
	staircase-structure occuring in the problem formulation. We
	present computational results for all the algorithms,
	including a comparison of the MIP and SAT-approaches. Our
	developed approaches allow to find the proven optimal solution
	for eight instances from literature, where the optimal
	solution was unknown and also provide reduced gaps for eleven
	additional instances, including improved solution values for
	seven instances, the largest optimality gap is now
	46%. Instances based on the problem were submitted to the SAT
	Competition 2020.	
      </p>

  </li></ul>

  <p>
  
</p><h2>MIAO seminars spring 2020</h2>


<p>
  
</p><ul>
    <li>
      <p>
	Wednesday Jul 15 at 15:00 <br>
	<strong>
	  Naïve algorithm selection for SAT solving
	</strong> <br>
	(Stephan Gocht,
	Lund University and University of Copenhagen)
      </p>

      <p>
      Although solving propositional formulas is an NP-complete
      problem, state-of-the-art SAT solvers are able to solve formulas
      with millions of variables. To obtain good performance it is
      necessary to configure parameters for heuristic
      decisions. However, there is no single parameter configuration
      that is perfect for all formulas, and choosing the parameters is
      a difficult task. The standard approach is to evaluate different
      configurations on some formulas and to choose the single
      configuration, that performs best overall. This configuration,
      which is called single best solver, is then used to solve new
      unseen formulas. In this paper we demonstrate how random forests
      can be used to choose a configuration dynamically based on
      simple features of the formula. The evaluation shows that our
      approach is able to outperform the single best solver on
      formulas that are similar to the training set, but not on
      formulas from completely new domains.
      </p>
	
    </li><li>      
      <p>
	Friday Jun 26 at 10:00 <br>
	<strong>
	  Behind the scenes of chronological CDCL
	</strong> <br>
	(Sibylle Möhle and Armin Biere,
	Johannes Kepler University Linz)
      </p>

      <p>	
	Combining conflict-driven clause learning (CDCL) with
	chronological backtracking is challenging: Multiple invariants
	considered crucial in modern SAT solvers are violated, if
	after conflict analysis the solver does not jump to the
	assertion level but to a higher decision level instead. In
	their SAT'18 paper "Chronological Backtracking", Alexander
	Nadel and Vadim Ryvchim provide a fix to this issue. Moreover,
	their SAT solver implementing chronological backtracking won
	the main track of the SAT Competition 2018. In our SAT'19
	paper, "Backing Backtracking", we present a formalization and
	generalization of this method. We prove its correctness and
	provide an independent implementation.
      </p>
      
      <p>
	In this seminar, we demonstrate the working of chronological
	CDCL by means of an example. In this example, after a conflict
	the conflicting clause contains only one literal at conflict
	level. It is therefore used as a reason for backtracking, thus
	saving the effort of conflict analysis. We further show which
	invariants are violated and present new ones followed by a
	discussion of the rules of our formal framework. We also shed
	light onto implementation details, including those which are
	not mentioned in our SAT'19 paper.
      </p>

    </li><li>      
      <p>
	Monday Jun 22 at 13:30 <br>
	<strong>
	  McSplit: A partitioning algorithm for maximum common subgraph
	  problems
	</strong> <br>
	(Ciaran McCreesh and James Trimble,
	University of Glasgow)
      </p>

      <p>
	We will give a short introduction to McSplit, an algorithm for
	the maximum common (connected) subgraph problem coauthored
	with Patrick Prosser and presented at IJCAI 2017. McSplit
	resembles a forward-checking constraint programming algorithm,
	but uses a partitioning data structure to store domains which
	greatly reduces memory use and time per search node. We will
	also present our recent work with Stephan Gocht and Jakob
	Nordström on adding proof logging to the algorithm, turning
	McSplit into a certifying algorithm whose outputs can be
	independently verified.
      </p>

    </li><li>
      <p>
	Thursday Jun 18 at 20:30 <br>
	<strong>
	  A pseudo-Boolean approach to nonlinear verification
	</strong> <br>
	(Vincent Liew,
	University of Washington)
      </p>

      <p>
	We discuss some new experimental results showing the promise
	of using pseudo-Boolean solvers, rather than SAT solvers, to
	verify bit-vector problems containing multiplication. We use
	this approach to efficiently verify the commutativity of a
	multiplier output bit by output bit. We also give some examples
	of simple bit-vector inequalities where the pseudo-Boolean
	approach significantly outperformed SAT solvers and even
	bit-vector solvers. Finally, we give some of our observations on
	the strengths and weaknesses of different methods of conflict
	analysis used by pseudo-Boolean solvers.
      </p>
      
    </li><li>
      <p>
	Friday May 8 at 13:15 <br>
	<strong>
	  Pseudo-Boolean solvers for answer set programming
	</strong> <br>
	(Bart Bogaerts, Vrije Universiteit Brussel)
      </p>

      <p>
      Answer set programming (ASP) is a well-established knowledge
      representation formalism. Most ASP solvers are based on
      (extensions of) technology from Boolean satisfiability
      solving. While these solvers have shown to be very successful in
      many practical applications, their strength is limited by their
      underlying proof system, resolution. In this research, we
      present a new tool LP2PB that translates ASP programs into
      pseudo-Boolean theories, for which solvers based on the
      (stronger) cutting plane proof system exist. We evaluate our
      tool, and the potential of cutting-plane-based solving for ASP
      on traditional ASP benchmarks as well as benchmarks from
      pseudo-Boolean solving. Our results are mixed: overall,
      traditional ASP solvers still outperform our translational
      approach, but several benchmark families are identified where
      the balance shifts the other way, thereby suggesting that
      further investigation into a stronger proof system for ASP is
      valuable.
      </p>

  </li></ul>
  

<!-- Do not change below this point (except for date) -->

</div>
</td>
</tr>
</tbody></table>

<!-- sidfoten -->
<div class="fotstreck_smalt"></div>
<div class="fotstreck_gratt_med_rutor"></div>
<div class="fotstreck_vitt_med_rutor"></div>
<div class="sidfottext">

<strong>
  Published by:</strong> Jakob Nordström
<a href="mailto:jn~at-sign~di~dot~ku~dot~dk">&lt;jn~at-sign~di~dot~ku~dot~dk&gt;</a>
<br>
Updated 2022-11-09
</div>
<!--/eri-no-index-->



<!-- Default Statcounter code for Jakob's GitHub webpages
https://jakobnordstrom.github.io -->
<script type="text/javascript">
var sc_project=12521096; 
var sc_invisible=1; 
var sc_security="a648a4cc"; 
var sc_remove_link=1; 
</script>
<script type="text/javascript"
src="https://www.statcounter.com/counter/counter.js"
async></script>
<noscript><div class="statcounter"><img class="statcounter"
src="https://c.statcounter.com/12521096/0/a648a4cc/1/"
alt="Web Analytics Made Easy -
StatCounter"></div></noscript>
<!-- End of Statcounter Code -->


</body></html>

